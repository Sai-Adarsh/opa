<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Open Policy Agent</title><link>https://openpolicyagent.org/docs/v0.10.7/</link><description>Recent content in Introduction on Open Policy Agent</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://openpolicyagent.org/docs/v0.10.7/index.xml" rel="self" type="application/rss+xml"/><item><title>Get started</title><link>https://openpolicyagent.org/docs/v0.10.7/get-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/get-started/</guid><description>The Open Policy Agent (OPA) is an open source, general-purpose policy engine that enables unified, context-aware policy enforcement across the entire stack.
OPA provides a high-level declarative language for authoring policies and simple APIs to answer policy queries. Using OPA, you can offload policy decisions from your service such as:
Should this API call be allowed? E.g., true or false. How much quota remains for this user? E.g., 1048.</description></item><item><title>Guides: Identity and User Attributes</title><link>https://openpolicyagent.org/docs/v0.10.7/guides-identity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/guides-identity/</guid><description>A common question from OPA users is how to deal with identity and user attributes. The first thing to keep in mind is that OPA does not handle authentication. OPA does not help users prove they are who they say they are; it does not handle usernames and passwords, or issue TLS certificates. OPA assumes you have authentication in place and helps you with the step after that: authorization and policy&amp;ndash;controlling who can do what.</description></item><item><title>How Does OPA Work?</title><link>https://openpolicyagent.org/docs/v0.10.7/how-does-opa-work/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/how-does-opa-work/</guid><description>OPA is a full-featured policy engine that offloads policy decisions from your service. You can think of it as a concierge for your service who can answer detailed questions on behalf of your users to meet their specific needs.
Overview OPA’s RESTful APIs use JSON over HTTP so you and your users can integrate OPA with any programming language. At a high level, integrating OPA into your service involves:</description></item><item><title>Docker Authorization</title><link>https://openpolicyagent.org/docs/v0.10.7/docker-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/docker-authorization/</guid><description>Docker’s out-of-the-box authorization model is all or nothing. But many users require finer-grained access control and Docker’s plugin infrastructure allows us to do so.
This is an excellent opportunity to see how to policy enable an existing service.
Goals This tutorial helps you get started with OPA and introduces you to core concepts in OPA.
Policy enabling an application decouples the policy implementation from the business logic so that administrators can define policy without changing the application while still keeping up with the size, complexity, and dynamic nature of modern applications.</description></item><item><title>Guides: Kubernetes Admission Control</title><link>https://openpolicyagent.org/docs/v0.10.7/guides-kubernetes-admission-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/guides-kubernetes-admission-control/</guid><description>In Kubernetes, Admission Controllers enforce semantic validation of objects during create, update, and delete operations. With OPA you can enforce custom policies on Kubernetes objects without recompiling or reconfiguring the Kubernetes API server or even Kubernetes Admission Controllers.
This primer assumes you, the Kubernetes administrator, have already installed OPA as a validating admission controller on Kubernetes as described in the Kubernetes Admission Control Tutorial. And now you are at the point where you want to write your own policies.</description></item><item><title>How Do I Write Policies?</title><link>https://openpolicyagent.org/docs/v0.10.7/how-do-i-write-policies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/how-do-i-write-policies/</guid><description>OPA is purpose built for reasoning about information represented in structured documents. The data that your service and its users publish can be inspected and transformed using OPA’s native query language Rego.
What is Rego? Rego was inspired by Datalog, which is a well understood, decades old query language. Rego extends Datalog to support structured document models such as JSON.
Rego queries are assertions on data stored in OPA. These queries can be used to define policies that enumerate instances of data that violate the expected state of the system.</description></item><item><title>HTTP API Authorization</title><link>https://openpolicyagent.org/docs/v0.10.7/http-api-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/http-api-authorization/</guid><description>Anything that exposes an HTTP API (whether an individual microservice or an application as a whole) needs to control who can run those APIs and when. OPA makes it easy to write fine-grained, context-aware policies to implement API authorization.
Goals In this tutorial, you&amp;rsquo;ll use a simple HTTP web server that accepts any HTTP GET request that you issue and echoes the OPA decision back as text. Both OPA and the web server will be run as containers.</description></item><item><title>How Do I Test Policies?</title><link>https://openpolicyagent.org/docs/v0.10.7/how-do-i-test-policies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/how-do-i-test-policies/</guid><description>OPA gives you a high-level declarative language (Rego) to author fine-grained policies that codify important requirements in your system.
To help you verify the correctness of your policies, OPA also gives you a framework that you can use to write tests for your policies. By writing tests for your policies you can speed up the development process of new rules and reduce the amount of time it takes to modify rules as requirements evolve.</description></item><item><title>Language Reference</title><link>https://openpolicyagent.org/docs/v0.10.7/language-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/language-reference/</guid><description>This document is the authoritative specification of the Rego policy language (V1). All policies in OPA are written in Rego.
Built-in Functions The built-in functions for the language provide basic operations to manipulate scalar values (e.g. numbers and strings), and aggregate functions that summarize complex types.
Comparison Built-in Description x == y x is equal to y x != y x is not equal to y x &amp;lt; y x is less than y x &amp;lt;= y x is less than or equal to y x &amp;gt; y x is greater than y x &amp;gt;= y x is greater than or equal to y Numbers Built-in Description z := x + y z is the sum of x and y z := x - y z is the difference of x and y z := x * y z is the product of x and y z := x / y z is the quotient of x and y z := x % y z is the remainder from the division of x and y output := round(x) output is x rounded to the nearest integer output := abs(x) output is the absolute value of x Aggregates Built-in Description output := count(collection_or_string) output is the length of the object, array, set, or string provided as input output := sum(array_or_set) output is the sum of the numbers in array_or_set output := product(array_or_set) output is the product of the numbers in array_or_set output := max(array_or_set) output is the maximum value in array_or_set output := min(array_or_set) output is the minimum value in array_or_set output := sort(array_or_set) output is the sorted array containing elements from array_or_set.</description></item><item><title>SSH and sudo Authorization</title><link>https://openpolicyagent.org/docs/v0.10.7/ssh-and-sudo-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/ssh-and-sudo-authorization/</guid><description>Host-level access controls are an important part of every organization&amp;rsquo;s security strategy. Using Linux-PAM and OPA we can extend policy-based access control to SSH and sudo.
Goals This tutorial shows how you can use OPA and Linux-PAM to enforce fine-grained, host-level access controls over SSH and sudo.
Linux-PAM can be configured to delegate authorization decisions to plugins (shared libraries). In this case, we have created an OPA-based plugin that can be configured to authorize SSH and sudo access.</description></item><item><title>Configuration Reference</title><link>https://openpolicyagent.org/docs/v0.10.7/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/configuration/</guid><description>This page defines the format of OPA configuration files. Fields marked as required must be specified if the parent is defined. For example, when the configuration contains a status key, the status.service field must be defined.
The configuration file path is specified with the -c or --config-file command line argument:
opa run -s -c config.yaml Example services:-name:acmecorpurl:https://example.com/control-plane-api/v1credentials:bearer:token:&amp;#34;bGFza2RqZmxha3NkamZsa2Fqc2Rsa2ZqYWtsc2RqZmtramRmYWxkc2tm&amp;#34;labels:app:myappregion:westenvironment:productionbundle:name:http/example/authzservice:acmecorpprefix:bundlespolling:min_delay_seconds:60max_delay_seconds:120decision_logs:service:acmecorpreporting:min_delay_seconds:300max_delay_seconds:600status:service:acmecorpdefault_decision:/http/example/authz/allow Services Services represent endpoints that implement one or more control plane APIs such as the Bundle or Status APIs.</description></item><item><title>Kafka Authorization</title><link>https://openpolicyagent.org/docs/v0.10.7/kafka-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/kafka-authorization/</guid><description>Apache Kafka is a high-performance distributed streaming platform deployed by thousands of companies. In many deployments, administrators require fine-grained access control over Kafka topics to enforce important requirements around confidentiality and integrity.
Goals This tutorial shows how to enforce fine-grained access control over Kafka topics. In this tutorial you will use OPA to define and enforce an authorization policy stating:
Consumers of topics containing Personally Identifiable Information (PII) must be whitelisted.</description></item><item><title>Kubernetes Admission Control</title><link>https://openpolicyagent.org/docs/v0.10.7/kubernetes-admission-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/kubernetes-admission-control/</guid><description>In Kubernetes, Admission Controllers enforce semantic validation of objects during create, update, and delete operations. With OPA you can enforce custom policies on Kubernetes objects without recompiling or reconfiguring the Kubernetes API server.
Goals This tutorial shows how to enforce custom policies on Kubernetes objects using OPA. In this tutorial, you will define admission control rules that prevent users from creating Kubernetes Ingress objects that violate the following organization policy:</description></item><item><title>REST API</title><link>https://openpolicyagent.org/docs/v0.10.7/rest-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/rest-api/</guid><description>This document is the authoritative specification of the OPA REST API.
Policy API The Policy API exposes CRUD endpoints for managing policy modules. Policy modules can be added, removed, and modified at any time.
The identifiers given to policy modules are only used for management purposes. They are not used outside of the Policy API.
List Policies GET /v1/policies HTTP/1.1 List policy modules.
Status Codes 200 - no error 500 - server error Example Request GET /v1/policies HTTP/1.</description></item><item><title>Deployments</title><link>https://openpolicyagent.org/docs/v0.10.7/deployments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/deployments/</guid><description>This document helps you get OPA up and running in different deployment environments. You should read this document if you are planning to deploy OPA.
Docker Docker makes OPA easy to deploy in different types of environments.
This section explains how to use the official OPA Docker images. If this is your first time deploying OPA and you plan to use one of the Docker images, we recommend you review this section to familiarize yourself with the basics.</description></item><item><title>Terraform Testing</title><link>https://openpolicyagent.org/docs/v0.10.7/terraform/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/terraform/</guid><description>Terraform lets you describe the infrastructure you want and automatically creates, deletes, and modifies your existing infrastructure to match. OPA makes it possible to write policies that test the changes Terraform is about to make before it makes them. Such tests help in different ways:
tests help individual developers sanity check their Terraform changes tests can auto-approve run-of-the-mill infrastructure changes and reduce the burden of peer-review tests can help catch problems that arise when applying Terraform to production after applying it to staging Goals In this tutorial, you&amp;rsquo;ll learn how to use OPA to implement unit tests for Terraform plans that create and delete auto-scaling groups and servers.</description></item><item><title>Bundles</title><link>https://openpolicyagent.org/docs/v0.10.7/bundles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/bundles/</guid><description>OPA can periodically download bundles of policy and data from remote HTTP servers. The policies and data are loaded on the fly without requiring a restart of OPA. Once the policies and data have been loaded, they are enforced immediately. Policies and data loaded from bundles are accessible via the standard OPA REST API.
Bundles provide an alternative to pushing policies into OPA via the REST APIs. By configuring OPA to download bundles from a remote HTTP server, you can ensure that OPA has an up-to-date copy of policies and data required for enforcement at all times.</description></item><item><title>Ceph Authorization</title><link>https://openpolicyagent.org/docs/v0.10.7/ceph-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/ceph-authorization/</guid><description>Ceph is a highly scalable distributed storage solution that uniquely delivers object, block, and file storage in one unified system. You can enforce fine-grained authorization over Ceph&amp;rsquo;s Object Storage using OPA. Ceph&amp;rsquo;s Object Storage essentially consists of a Ceph Storage Cluster and a Ceph Object Gateway.
The Ceph Object Gateway is an object storage interface built on top of librados to provide applications with a RESTful gateway to Ceph Storage Clusters.</description></item><item><title>Status</title><link>https://openpolicyagent.org/docs/v0.10.7/status/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/status/</guid><description>OPA can periodically report status updates to remote HTTP servers. The updates contain status information for OPA itself as well as the Bundles that have been downloaded and activated.
OPA sends status reports whenever bundles are downloaded and activated. If the bundle download or activation fails for any reason, the status update will include error information describing the failure.
The status updates will include a set of labels that uniquely identify the OPA instance.</description></item><item><title>Decision Logs</title><link>https://openpolicyagent.org/docs/v0.10.7/decision-logs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/decision-logs/</guid><description>OPA can periodically report decision logs to remote HTTP servers. The decision logs contain events that describe policy queries. Each event includes the policy that was queried, the input to the query, bundle metadata, and other information that enables auditing and offline debugging of policy decisions.
When decision logging is enabled the OPA server will include a decision_id field in API calls that return policy decisions.
See the Configuration Reference for configuration details.</description></item><item><title>Monitoring</title><link>https://openpolicyagent.org/docs/v0.10.7/monitoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/monitoring/</guid><description>Prometheus OPA exposes an HTTP endpoint that can be used to collect performance metrics for all API calls. The Prometheus endpoint is enabled by default when you run OPA as a server.
You can enable metric collection from OPA with the following prometheus.yml config:
global_config:scrape_interval:15sscrape_configs:-job_name:&amp;#34;opa&amp;#34;metrics_path:&amp;#34;/metrics&amp;#34;static_configs:-targets:-&amp;#34;localhost:8181&amp;#34; Diagnostics (Deprecated) The diagnostics feature is deprecated. If you need to monitor OPA decisions, see the Decision Log API.</description></item><item><title>Discovery</title><link>https://openpolicyagent.org/docs/v0.10.7/discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/discovery/</guid><description>OPA can be configured to download bundles of policy and data, report status, and upload decision logs to remote endpoints. The discovery feature helps you centrally manage the OPA configuration for these features. You should use the discovery feature if you want to avoid managing OPA configuration updates in number of different locations.
When the discovery feature is enabled, OPA will periodically download a discovery bundle. Like regular bundles, the discovery bundle may contain JSON and Rego files.</description></item><item><title>Security</title><link>https://openpolicyagent.org/docs/v0.10.7/security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/security/</guid><description>This document provides guidelines for deploying OPA inside untrusted environments. You should read this document if you are deploying OPA as a service.
Securing the API involves configuring OPA to use TLS, authentication, and authorization so that:
Traffic between OPA and clients is encrypted. Clients verify the OPA API endpoint identity. OPA verifies client identities. Clients are only granted access to specific APIs or sections of The data Document.</description></item><item><title>Plugins (Experimental)</title><link>https://openpolicyagent.org/docs/v0.10.7/plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/plugins/</guid><description>OPA can be extended with custom built-in functions and plugins that implement functionality like support for new protocols.
This page focuses on how to build Go plugins that can be loaded when OPA starts however the steps are similar if you are embedding OPA as a library or building from source.
Building Go Plugins At minimum, your Go plugin must implement the following:
package main func Init() error { // your init function } When OPA starts, it will invoke the Init function which can:</description></item><item><title>Comparison to Other Systems</title><link>https://openpolicyagent.org/docs/v0.10.7/comparison-to-other-systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/comparison-to-other-systems/</guid><description>Often the easiest way to understand a new language is by comparing it to languages you already know. Here we show how policies from several existing policy systems can be implemented with the Open Policy Agent.
Role-based access control (RBAC) Role-based access control (RBAC) is pervasive today for authorization. To use RBAC for authorization, you write down two different kinds of information.
Which users have which roles Which roles have which permissions Once you provide RBAC with both those assignments, RBAC tells you how to make an authorization decision.</description></item><item><title>Frequently Asked Questions</title><link>https://openpolicyagent.org/docs/v0.10.7/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/faq/</guid><description>How do I make user attributes stored in LDAP/AD available to OPA for making decisions? This best-practice guide explains three options: JSON Web Tokens, synchronization with LDAP/AD, and calling into LDAP/AD during policy evaluation.
How does OPA do conflict resolution? In Rego (OPA&amp;rsquo;s policy language), you can write statements that both allow and deny a request, such as
package foo allow { input.name == &amp;#34;alice&amp;#34; } deny { input.name == &amp;#34;alice&amp;#34; } Neither allow nor deny are keywords in Rego so if you want to treat them as contradictory, you control which one takes precedence explicitly.</description></item><item><title>Rego Cheatsheet</title><link>https://openpolicyagent.org/docs/v0.10.7/rego-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://openpolicyagent.org/docs/v0.10.7/rego-cheatsheet/</guid><description>Equality # Outside of a rule, assign variable `whitelist` to the set `hooli.com` and `initech.com` whitelist = {&amp;#34;hooli.com&amp;#34;, &amp;#34;initech.com&amp;#34;} # Inside of a rule, assign LOCAL variable `x` to the value of label `costcenter` x := input.request.metadata.labels.costcenter # Check if variable `x` and `y` have the same value x == y # Check if variable `whitelist` has value {&amp;#34;hooli.com&amp;#34;, &amp;#34;initech.com&amp;#34;} whitelist == {&amp;#34;hooli.com&amp;#34;, &amp;#34;initech.com&amp;#34;} # OR {&amp;#34;hooli.com&amp;#34;, &amp;#34;initech.com&amp;#34;} == whitelist Lookup # Array: lookup value at index 0 val := arr[0] # Array: lookup all indexes with value &amp;#34;foo&amp;#34; &amp;#34;foo&amp;#34; == arr[i] # Array: check if index 0 has value &amp;#34;foo&amp;#34; &amp;#34;foo&amp;#34; == arr[0] # Array: last element val := arr[count(arr) - 1] # Object: lookup value for key &amp;#34;foo&amp;#34; val := obj[&amp;#34;foo&amp;#34;] # Object: lookup keys for value &amp;#34;bar&amp;#34; &amp;#34;bar&amp;#34; == obj[k] # Object: check if key &amp;#34;foo&amp;#34; has value &amp;#34;bar&amp;#34; &amp;#34;bar&amp;#34; == obj[&amp;#34;foo&amp;#34;] OR &amp;#34;bar&amp;#34; == obj.</description></item></channel></rss>